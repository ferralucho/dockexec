# This test probably only works on Unix-y systems. That's fine for now.
[!exec:go] skip
[!exec:docker] skip
[!symlink] skip

# We want to use the current dockexec, not whichever happens to be globally
# installed. Use the test binary with TESTSCRIPT_COMMAND, which we know will
# correctly run dockexec thanks to go-internal/testscript.
mkdir .bin
symlink .bin/dockexec -> $TESTBIN
env PATH=.bin:$PATH
env TESTSCRIPT_COMMAND=dockexec

# Check that we succeed without -exec.
exec go test
! stdout 'TestWithBusybox'
stdout 'PASS'

# Check that we fail with an invalid image.
! exec go test -exec='dockexec :bad:syntax:'
stdout 'docker:'

# Check that we succeed with just a simple image, and that the test requiring
# busybox isn't skipped.
exec go test -exec='dockexec busybox:1.31.1-musl' -v
! stdout 'SKIP.*TestWithBusybox'
stdout 'PASS.*TestWithBusybox'
stdout 'PASS'

# Check that test flags, even custom ones, work.
exec go test -exec='dockexec busybox:1.31.1-musl' -v -myflag
! stdout 'SKIP.*TestWithMyFlag'
stdout 'PASS.*TestWithMyFlag'
stdout 'PASS'

-- go.mod --
module foo.com/bar

-- f.go --
package bar

func True() bool { return true }

-- f_test.go --
package bar

import (
	"flag"
	"os/exec"
	"testing"
)

var myflag = flag.Bool("myflag", false, "")

func TestTrue(t *testing.T) {
	if True() != true {
		t.FailNow()
	}
}

func TestWithBusybox(t *testing.T) {
	if _, err := exec.LookPath("busybox"); err != nil {
		t.Skip("busybox not installed")
	}
}

func TestWithMyFlag(t *testing.T) {
	if !*myflag {
		t.Skip("-myflag not specified")
	}
}
